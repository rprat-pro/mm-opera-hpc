/*!
* \file   TFEL/Material/MonoCristal_UO2.hxx
* \brief  this file implements the MonoCristal_UO2 Behaviour.
*         File generated by tfel version 4.2.0-dev
* \author Luc Portelette / Thomas Helfer / Etienne Castelier
 */

#ifndef LIB_TFELMATERIAL_MONOCRISTAL_UO2_HXX
#define LIB_TFELMATERIAL_MONOCRISTAL_UO2_HXX

#include<string>
#include<iostream>
#include<limits>
#include<stdexcept>
#include<algorithm>

#include"TFEL/Raise.hxx"
#include"TFEL/PhysicalConstants.hxx"
#include"TFEL/Config/TFELConfig.hxx"
#include"TFEL/Config/TFELTypes.hxx"
#include"TFEL/TypeTraits/IsFundamentalNumericType.hxx"
#include"TFEL/TypeTraits/IsReal.hxx"
#include"TFEL/Math/General/IEEE754.hxx"
#include"TFEL/Material/MaterialException.hxx"
#include"TFEL/Material/MechanicalBehaviour.hxx"
#include"TFEL/Material/MechanicalBehaviourTraits.hxx"
#include"TFEL/Material/OutOfBoundsPolicy.hxx"
#include"TFEL/Material/BoundsCheck.hxx"
#include"TFEL/Material/IsotropicPlasticity.hxx"
#include"TFEL/Material/Lame.hxx"
#include"TFEL/Material/Hosford1972YieldCriterion.hxx"
#include"TFEL/Material/OrthotropicPlasticity.hxx"
#include"TFEL/Material/OrthotropicStressLinearTransformation.hxx"
#include"TFEL/Material/Hill.hxx"
#include"TFEL/Material/Barlat2004YieldCriterion.hxx"
#include"TFEL/Material/OrthotropicAxesConvention.hxx"
#include"TFEL/Material/MonoCristal_UO2BehaviourData.hxx"
#include"TFEL/Material/MonoCristal_UO2IntegrationData.hxx"

#include"TFEL/Math/Array/ViewsArray.hxx"
#include"TFEL/Math/tvector.hxx"
#include"TFEL/Math/Vector/tvectorIO.hxx"
#include"TFEL/Math/tmatrix.hxx"
#include"TFEL/Math/Matrix/tmatrixIO.hxx"
#include"TFEL/Math/st2tost2.hxx"
#include"TFEL/Math/ST2toST2/ST2toST2ConceptIO.hxx"
#include"TFEL/Math/TinyNewtonRaphsonSolver.hxx"
#include"TFEL/Math/General/CubicRoots.hxx"
#include "TFEL/Material/MonoCristal_UO2SlipSystems.hxx"

#include"MFront/Castem/Castem.hxx"

namespace tfel::material{

struct MonoCristal_UO2TridimensionalParametersInitializer
{
static MonoCristal_UO2TridimensionalParametersInitializer&
get();


void set(const char* const,const double);

void set(const char* const,const unsigned short);

private :

MonoCristal_UO2TridimensionalParametersInitializer();

MonoCristal_UO2TridimensionalParametersInitializer(const MonoCristal_UO2TridimensionalParametersInitializer&);

MonoCristal_UO2TridimensionalParametersInitializer&
operator=(const MonoCristal_UO2TridimensionalParametersInitializer&);
/*!
 * \brief read the parameters from the given file
 * \param[out] pi : parameters initializer
 * \param[in]  fn : file name
 */
static void readParameters(MonoCristal_UO2TridimensionalParametersInitializer&,const char* const);
};

struct MonoCristal_UO2ParametersInitializer
{
static MonoCristal_UO2ParametersInitializer&
get();

double epsilon;
double theta;
unsigned short iterMax;
double minimal_time_step_scaling_factor;
double maximal_time_step_scaling_factor;
double numerical_jacobian_epsilon;

void set(const char* const,const double);

void set(const char* const,const unsigned short);

/*!
 * \brief convert a string to double
 * \param[in] p : parameter
 * \param[in] v : value
 */
static double getDouble(const std::string&,const std::string&);
/*!
 * \brief convert a string to unsigned short
 * \param[in] p : parameter
 * \param[in] v : value
 */
static unsigned short getUnsignedShort(const std::string&,const std::string&);
private :

MonoCristal_UO2ParametersInitializer();

MonoCristal_UO2ParametersInitializer(const MonoCristal_UO2ParametersInitializer&);

MonoCristal_UO2ParametersInitializer&
operator=(const MonoCristal_UO2ParametersInitializer&);
/*!
 * \brief read the parameters from the given file
 * \param[out] pi : parameters initializer
 * \param[in]  fn : file name
 */
static void readParameters(MonoCristal_UO2ParametersInitializer&,const char* const);
};

//! \brief forward declaration
template<ModellingHypothesis::Hypothesis, typename NumericType, bool use_qt>
struct MonoCristal_UO2;

//! \brief forward declaration
template<ModellingHypothesis::Hypothesis hypothesis, typename NumericType>
std::ostream&
 operator <<(std::ostream&,const MonoCristal_UO2<hypothesis, NumericType, false>&);

//! \brief forward declaration
template<typename NumericType>
std::ostream&
 operator <<(std::ostream&,const MonoCristal_UO2<ModellingHypothesis::TRIDIMENSIONAL, NumericType, false>&);

/*!
* \class MonoCristal_UO2
* \brief This class implements the MonoCristal_UO2 behaviour.
* \tparam hypothesis: modelling hypothesis.
* \tparam NumericType: numerical type.
* \author Luc Portelette / Thomas Helfer / Etienne Castelier
* Loi de plasticité cristalline UO2 
* glissement devier/combiné (GD/C ou GD-C) 
*/
template<typename NumericType>
struct MonoCristal_UO2<ModellingHypothesis::TRIDIMENSIONAL, NumericType, false> final
: public MechanicalBehaviour<MechanicalBehaviourBase::STANDARDFINITESTRAINBEHAVIOUR,ModellingHypothesis::TRIDIMENSIONAL, NumericType, false>,
public MonoCristal_UO2BehaviourData<ModellingHypothesis::TRIDIMENSIONAL, NumericType, false>,
public MonoCristal_UO2IntegrationData<ModellingHypothesis::TRIDIMENSIONAL, NumericType, false>,
public tfel::math::TinyNewtonRaphsonSolver<ModellingHypothesisToStensorSize<ModellingHypothesis::TRIDIMENSIONAL>::value+24, NumericType, MonoCristal_UO2<ModellingHypothesis::TRIDIMENSIONAL, NumericType, false>>{

static constexpr ModellingHypothesis::Hypothesis hypothesis = ModellingHypothesis::TRIDIMENSIONAL;
static constexpr unsigned short N = ModellingHypothesisToSpaceDimension<hypothesis>::value;

static_assert(N==1||N==2||N==3);
static_assert(tfel::typetraits::IsFundamentalNumericType<NumericType>::cond);
static_assert(tfel::typetraits::IsReal<NumericType>::cond);

friend std::ostream& operator<< <>(std::ostream&,const MonoCristal_UO2&);

friend struct tfel::math::TinyNonLinearSolverBase<ModellingHypothesisToStensorSize<ModellingHypothesis::TRIDIMENSIONAL>::value+24, NumericType, MonoCristal_UO2>;
static constexpr unsigned short TVectorSize = N;
typedef tfel::math::StensorDimeToSize<N> StensorDimeToSize;
static constexpr unsigned short StensorSize = StensorDimeToSize::value;
typedef tfel::math::TensorDimeToSize<N> TensorDimeToSize;
static constexpr unsigned short TensorSize = TensorDimeToSize::value;

using ushort =  unsigned short;
using Types = tfel::config::Types<N, NumericType, false>;
using Type = NumericType;
using numeric_type = typename Types::numeric_type;
using real = typename Types::real;
using time = typename Types::time;
using length = typename Types::length;
using frequency = typename Types::frequency;
using speed = typename Types::speed;
using stress = typename Types::stress;
using strain = typename Types::strain;
using strainrate = typename Types::strainrate;
using stressrate = typename Types::stressrate;
using temperature = typename Types::temperature;
using thermalexpansion = typename Types::thermalexpansion;
using thermalconductivity = typename Types::thermalconductivity;
using massdensity = typename Types::massdensity;
using energydensity = typename Types::energydensity;
using TVector = typename Types::TVector;
using DisplacementTVector = typename Types::DisplacementTVector;
using ForceTVector = typename Types::ForceTVector;
using HeatFlux = typename Types::HeatFlux;
using TemperatureGradient = typename Types::TemperatureGradient;
using Stensor = typename Types::Stensor;
using StressStensor = typename Types::StressStensor;
using StressRateStensor = typename Types::StressRateStensor;
using StrainStensor = typename Types::StrainStensor;
using StrainRateStensor = typename Types::StrainRateStensor;
using FrequencyStensor = typename Types::FrequencyStensor;
using Tensor = typename Types::Tensor;
using DeformationGradientTensor = typename Types::DeformationGradientTensor;
using DeformationGradientRateTensor = typename Types::DeformationGradientRateTensor;
using StressTensor = typename Types::StressTensor;
using StiffnessTensor = typename Types::StiffnessTensor;
using Stensor4 = typename Types::Stensor4;
using TangentOperator = FiniteStrainBehaviourTangentOperator<N,stress>;
using PhysicalConstants = tfel::PhysicalConstants<NumericType, false>;

public :

typedef MonoCristal_UO2BehaviourData<hypothesis, NumericType, false> BehaviourData;
typedef MonoCristal_UO2IntegrationData<hypothesis, NumericType, false> IntegrationData;
typedef typename MechanicalBehaviour<MechanicalBehaviourBase::STANDARDFINITESTRAINBEHAVIOUR,hypothesis, NumericType, false>::SMFlag SMFlag;
typedef typename MechanicalBehaviour<MechanicalBehaviourBase::STANDARDFINITESTRAINBEHAVIOUR,hypothesis, NumericType, false>::SMType SMType;
using MechanicalBehaviour<MechanicalBehaviourBase::STANDARDFINITESTRAINBEHAVIOUR,hypothesis, NumericType, false>::ELASTIC;
using MechanicalBehaviour<MechanicalBehaviourBase::STANDARDFINITESTRAINBEHAVIOUR,hypothesis, NumericType, false>::SECANTOPERATOR;
using MechanicalBehaviour<MechanicalBehaviourBase::STANDARDFINITESTRAINBEHAVIOUR,hypothesis, NumericType, false>::TANGENTOPERATOR;
using MechanicalBehaviour<MechanicalBehaviourBase::STANDARDFINITESTRAINBEHAVIOUR,hypothesis, NumericType, false>::CONSISTENTTANGENTOPERATOR;
using MechanicalBehaviour<MechanicalBehaviourBase::STANDARDFINITESTRAINBEHAVIOUR,hypothesis, NumericType, false>::NOSTIFFNESSREQUESTED;
using MechanicalBehaviour<MechanicalBehaviourBase::STANDARDFINITESTRAINBEHAVIOUR,hypothesis, NumericType, false>::DSIG_DF;
using MechanicalBehaviour<MechanicalBehaviourBase::STANDARDFINITESTRAINBEHAVIOUR,hypothesis, NumericType, false>::DSIG_DDF;
using MechanicalBehaviour<MechanicalBehaviourBase::STANDARDFINITESTRAINBEHAVIOUR,hypothesis, NumericType, false>::C_TRUESDELL;
using MechanicalBehaviour<MechanicalBehaviourBase::STANDARDFINITESTRAINBEHAVIOUR,hypothesis, NumericType, false>::SPATIAL_MODULI;
using MechanicalBehaviour<MechanicalBehaviourBase::STANDARDFINITESTRAINBEHAVIOUR,hypothesis, NumericType, false>::C_TAU_JAUMANN;
using MechanicalBehaviour<MechanicalBehaviourBase::STANDARDFINITESTRAINBEHAVIOUR,hypothesis, NumericType, false>::ABAQUS;
using MechanicalBehaviour<MechanicalBehaviourBase::STANDARDFINITESTRAINBEHAVIOUR,hypothesis, NumericType, false>::DSIG_DDE;
using MechanicalBehaviour<MechanicalBehaviourBase::STANDARDFINITESTRAINBEHAVIOUR,hypothesis, NumericType, false>::DTAU_DF;
using MechanicalBehaviour<MechanicalBehaviourBase::STANDARDFINITESTRAINBEHAVIOUR,hypothesis, NumericType, false>::DTAU_DDF;
using MechanicalBehaviour<MechanicalBehaviourBase::STANDARDFINITESTRAINBEHAVIOUR,hypothesis, NumericType, false>::DS_DF;
using MechanicalBehaviour<MechanicalBehaviourBase::STANDARDFINITESTRAINBEHAVIOUR,hypothesis, NumericType, false>::DS_DDF;
using MechanicalBehaviour<MechanicalBehaviourBase::STANDARDFINITESTRAINBEHAVIOUR,hypothesis, NumericType, false>::DS_DC;
using MechanicalBehaviour<MechanicalBehaviourBase::STANDARDFINITESTRAINBEHAVIOUR,hypothesis, NumericType, false>::DS_DEGL;
using MechanicalBehaviour<MechanicalBehaviourBase::STANDARDFINITESTRAINBEHAVIOUR,hypothesis, NumericType, false>::DT_DELOG;
using MechanicalBehaviour<MechanicalBehaviourBase::STANDARDFINITESTRAINBEHAVIOUR,hypothesis, NumericType, false>::DPK1_DF;
using IntegrationResult = typename MechanicalBehaviour<MechanicalBehaviourBase::STANDARDFINITESTRAINBEHAVIOUR,hypothesis, NumericType, false>::IntegrationResult;

using MechanicalBehaviour<MechanicalBehaviourBase::STANDARDFINITESTRAINBEHAVIOUR,hypothesis, NumericType, false>::SUCCESS;
using MechanicalBehaviour<MechanicalBehaviourBase::STANDARDFINITESTRAINBEHAVIOUR,hypothesis, NumericType, false>::FAILURE;
using MechanicalBehaviour<MechanicalBehaviourBase::STANDARDFINITESTRAINBEHAVIOUR,hypothesis, NumericType, false>::UNRELIABLE_RESULTS;

using StressFreeExpansionType = StrainStensor;

private :

static constexpr auto Nss0 = int{6};
static constexpr auto Nss1 = int{6};
static constexpr auto Nss2 = int{12};
static constexpr auto Nss = int{24};

StrainStensor eel;

tfel::math::View<StrainStensor> deel;
tfel::math::ViewsFixedSizeVector<strain, ushort, 24> dg;

#line 21 "Mono_UO2_CosH_Jaco.mfront"
tfel::math::fsarray<24, real > tau0;
#line 22 "Mono_UO2_CosH_Jaco.mfront"
tfel::math::fsarray<24, real > gp0;
struct{
DeformationGradientTensor dF;
DeformationGradientTensor Fe_tr;
DeformationGradientTensor Fe0;
StressStensor S;
Tensor inv_dFp;
real J_inv_dFp;
StrainStensor tmp;
} fsscb_data;

NumericType epsilon;
NumericType theta;
ushort iterMax;
real minimal_time_step_scaling_factor;
real maximal_time_step_scaling_factor;
NumericType numerical_jacobian_epsilon;

//! Tangent operator;
TangentOperator Dt;
// updating material properties, in mandatory
void updateMaterialPropertiesDependantOnStateVariables(){
using namespace std;
using namespace tfel::math;
using std::vector;
}

/*!
 * \return the part of the jacobian matrix corresponding to the derivative of variable eel by variable g
 */
tfel::math::derivative_view_from_tiny_matrix<StensorSize+24, StrainStensor,strain> dfeel_ddg(tfel::math::tmatrix<StensorSize+24,StensorSize+24, NumericType>& tjacobian,const ushort mfront_idx){
return tfel::math::map_derivative<StrainStensor,strain>(tjacobian, 0, StensorSize + mfront_idx * (1));
}

tfel::math::derivative_view_from_tiny_matrix<StensorSize+24, StrainStensor,strain> dfeel_ddg(const ushort mfront_idx){
return tfel::math::map_derivative<StrainStensor,strain>(this->jacobian, 0, StensorSize + mfront_idx * (1));
}

/*!
 * \return the part of the jacobian matrix corresponding to the derivative of variable g by variable eel
 */
tfel::math::derivative_view_from_tiny_matrix<StensorSize+24, strain,StrainStensor> dfg_ddeel(tfel::math::tmatrix<StensorSize+24,StensorSize+24, NumericType>& tjacobian,const ushort mfront_idx){
return tfel::math::map_derivative<strain,StrainStensor>(tjacobian, StensorSize + mfront_idx * (1), 0);
}

tfel::math::derivative_view_from_tiny_matrix<StensorSize+24, strain,StrainStensor> dfg_ddeel(const ushort mfront_idx){
return tfel::math::map_derivative<strain,StrainStensor>(this->jacobian, StensorSize + mfront_idx * (1), 0);
}

/*!
 * \return the part of the jacobian matrix corresponding to the derivative of variable g by variable g
 */
tfel::math::derivative_view_from_tiny_matrix<StensorSize+24, strain,strain> dfg_ddg(tfel::math::tmatrix<StensorSize+24,StensorSize+24, NumericType>& tjacobian,const ushort mfront_idx, const ushort mfront_idx2){
return tfel::math::map_derivative<strain,strain>(tjacobian, StensorSize + mfront_idx * (1), StensorSize + mfront_idx2 * (1));
}

tfel::math::derivative_view_from_tiny_matrix<StensorSize+24, strain,strain> dfg_ddg(const ushort mfront_idx, const ushort mfront_idx2){
return tfel::math::map_derivative<strain,strain>(this->jacobian, StensorSize + mfront_idx * (1), StensorSize + mfront_idx2 * (1));
}

SMType stiffness_matrix_type;
void computeNumericalJacobian(tfel::math::tmatrix<StensorSize+24,StensorSize+24, NumericType>& njacobian)
{
using namespace std;
using namespace tfel::math;
tvector<StensorSize+24, NumericType> tzeros(this->zeros);
tvector<StensorSize+24, NumericType> tfzeros(this->fzeros);
tmatrix<StensorSize+24,StensorSize+24, NumericType> tjacobian(this->jacobian);
for(ushort mfront_idx = 0; mfront_idx != StensorSize+24; ++mfront_idx){
this->zeros(mfront_idx) -= this->numerical_jacobian_epsilon;
this->computeFdF(true);
this->zeros = tzeros;
tvector<StensorSize+24, NumericType> tfzeros2(this->fzeros);
this->zeros(mfront_idx) += this->numerical_jacobian_epsilon;
this->computeFdF(true);
this->fzeros = (this->fzeros-tfzeros2) / (2 * (this->numerical_jacobian_epsilon));
for(ushort mfront_idx2 = 0; mfront_idx2!= StensorSize+24; ++mfront_idx2){
njacobian(mfront_idx2,mfront_idx) = this->fzeros(mfront_idx2);
}
this->zeros    = tzeros;
this->fzeros   = tfzeros;
}
if(&njacobian!=&(this->jacobian)){
this->jacobian = tjacobian;
}
}

[[nodiscard]] bool
computePartialJacobianInvert(const tfel::math::TinyPermutation<StensorSize+24>& jacobian_permutation, tfel::math::derivative_type<StrainStensor, StrainStensor>& partial_jacobian_eel)
{
using namespace tfel::math;
for(ushort mfront_idx=0; mfront_idx !=StensorSize; ++mfront_idx){
tvector<StensorSize+24, NumericType> vect_e(NumericType(0));
vect_e(mfront_idx) = NumericType(1);
if(!TinyMatrixSolve<StensorSize+24, NumericType, false>::back_substitute(this->jacobian, jacobian_permutation, vect_e)){
return false;
}
for(ushort mfront_idx2=0; mfront_idx2!=StensorSize; ++mfront_idx2){
partial_jacobian_eel(mfront_idx2,mfront_idx)=vect_e(mfront_idx2);
}
}
return true;
}

[[nodiscard]] bool
computePartialJacobianInvert(const tfel::math::TinyPermutation<StensorSize+24>& jacobian_permutation, tfel::math::derivative_type<StrainStensor, StrainStensor>& partial_jacobian_eel,
tfel::math::tvector<24, tfel::math::derivative_type<strain, StrainStensor>>& partial_jacobian_g)
{
using namespace tfel::math;
for(ushort mfront_idx=0; mfront_idx !=StensorSize; ++mfront_idx){
tvector<StensorSize+24, NumericType> vect_e(NumericType(0));
vect_e(mfront_idx) = NumericType(1);
if(!TinyMatrixSolve<StensorSize+24, NumericType, false>::back_substitute(this->jacobian, jacobian_permutation, vect_e)){
return false;
}
for(ushort mfront_idx2=0; mfront_idx2!=StensorSize; ++mfront_idx2){
partial_jacobian_eel(mfront_idx2,mfront_idx)=vect_e(mfront_idx2);
}
for(ushort mfront_idx2=0; mfront_idx2!=24; ++mfront_idx2){
partial_jacobian_g(mfront_idx2)(mfront_idx)=vect_e(StensorSize+mfront_idx2);
}
}
return true;
}

void computeFinalThermodynamicForces(){
using namespace std;
using namespace tfel::math;
using std::vector;
const auto& ss = MonoCristal_UO2SlipSystems<real>::getSlidingSystems();
this->fsscb_data.inv_dFp = Tensor::Id();
for(unsigned short i=0;i!=MonoCristal_UO2SlipSystems<real>::Nss;++i){
  this->fsscb_data.inv_dFp -= dg[i]*ss.mu[i];
}
this->fsscb_data.J_inv_dFp = det(this->fsscb_data.inv_dFp);
this->fsscb_data.inv_dFp /= CubicRoots::cbrt(this->fsscb_data.J_inv_dFp);
this->Fe = (this->fsscb_data.Fe_tr)*(this->fsscb_data.inv_dFp);
this->fsscb_data.S = (this->D)*(this->eel);
this->sig = convertSecondPiolaKirchhoffStressToCauchyStress(this->fsscb_data.S,this->Fe);

} // end of MonoCristal_UO2::computeFinalThermodynamicForces

/*!
* \brief Update internal variables at end of integration
*/
void updateIntegrationVariables(){
this->eel += this->deel;
}

/*!
* \brief Update internal variables at end of integration
*/
void updateStateVariables(){
this->g += this->dg;
}

/*!
* \brief Update auxiliary state variables at end of integration
*/
void updateAuxiliaryStateVariables()
{}

//! \brief Default constructor (disabled)
MonoCristal_UO2() =delete ;
//! \brief Copy constructor (disabled)
MonoCristal_UO2(const MonoCristal_UO2&) = delete;
//! \brief Assignement operator (disabled)
MonoCristal_UO2& operator = (const MonoCristal_UO2&) = delete;

public:

/*!
* \brief Constructor
*/
MonoCristal_UO2(const MonoCristal_UO2BehaviourData<hypothesis, NumericType, false>& src1,
const MonoCristal_UO2IntegrationData<hypothesis, NumericType, false>& src2)
: MonoCristal_UO2BehaviourData<hypothesis, NumericType, false>(src1),
MonoCristal_UO2IntegrationData<hypothesis, NumericType, false>(src2),
deel(tfel::math::map<StrainStensor, 0>(this->zeros)),
dg(tfel::math::map<24, strain, StensorSize>(this->zeros))
{
using namespace std;
using namespace tfel::math;
using std::vector;
this->epsilon = MonoCristal_UO2ParametersInitializer::get().epsilon;
this->theta = MonoCristal_UO2ParametersInitializer::get().theta;
this->iterMax = MonoCristal_UO2ParametersInitializer::get().iterMax;
this->minimal_time_step_scaling_factor = MonoCristal_UO2ParametersInitializer::get().minimal_time_step_scaling_factor;
this->maximal_time_step_scaling_factor = MonoCristal_UO2ParametersInitializer::get().maximal_time_step_scaling_factor;
this->numerical_jacobian_epsilon = MonoCristal_UO2ParametersInitializer::get().numerical_jacobian_epsilon;
}

/*
 * \brief constructor for the Castem interface
 * \param[in] CASTEMdt_: time increment
 * \param[in] CASTEMT_: temperature
 * \param[in] CASTEMdT_: temperature increment
 * \param[in] CASTEMmat: material properties
 * \param[in] CASTEMint_vars: state variables
 * \param[in] CASTEMext_vars: external state variables
 * \param[in] CASTEMdext_vars: external state variables increments
 */
MonoCristal_UO2(const NumericType* const CASTEMdt_,
const NumericType* const CASTEMT_,
const NumericType* const CASTEMdT_,
const NumericType* const CASTEMmat,
const NumericType* const CASTEMint_vars,
const NumericType* const CASTEMext_vars,
const NumericType* const CASTEMdext_vars)
: MonoCristal_UO2BehaviourData<hypothesis, NumericType,false>(CASTEMT_,CASTEMmat,
CASTEMint_vars,CASTEMext_vars),
MonoCristal_UO2IntegrationData<hypothesis, NumericType,false>(CASTEMdt_,CASTEMdT_,CASTEMdext_vars),
deel(tfel::math::map<StrainStensor, 0>(this->zeros)),
dg(tfel::math::map<24, strain, StensorSize>(this->zeros))
{
using namespace std;
using namespace tfel::math;
using std::vector;
this->epsilon = MonoCristal_UO2ParametersInitializer::get().epsilon;
this->theta = MonoCristal_UO2ParametersInitializer::get().theta;
this->iterMax = MonoCristal_UO2ParametersInitializer::get().iterMax;
this->minimal_time_step_scaling_factor = MonoCristal_UO2ParametersInitializer::get().minimal_time_step_scaling_factor;
this->maximal_time_step_scaling_factor = MonoCristal_UO2ParametersInitializer::get().maximal_time_step_scaling_factor;
this->numerical_jacobian_epsilon = MonoCristal_UO2ParametersInitializer::get().numerical_jacobian_epsilon;
}

/*!
 * \ brief initialize the behaviour with user code
 */
[[nodiscard]] bool initialize(){
using namespace std;
using namespace tfel::math;
using std::vector;
this->fsscb_data.dF    = (this->F1)*invert(this->F0);
this->fsscb_data.Fe0   = this->Fe;
this->fsscb_data.Fe_tr = (this->fsscb_data.dF)*(this->fsscb_data.Fe0);
this->eel = computeGreenLagrangeTensor(this->Fe);

#line 25 "Mono_UO2_CosH_Jaco.mfront"
constexpr real kb = 1.38064852E-23;
#line 26 "Mono_UO2_CosH_Jaco.mfront"
constexpr real nuD = 4.9356532213000e13;
#line 27 "Mono_UO2_CosH_Jaco.mfront"
constexpr real a0 = 5.47e-10;
#line 28 "Mono_UO2_CosH_Jaco.mfront"
constexpr auto rhom = 1.0e12;
#line 29 "Mono_UO2_CosH_Jaco.mfront"
const real b = a0 * Cste<real>::isqrt2;
#line 30 "Mono_UO2_CosH_Jaco.mfront"
const auto T_ = this->T + theta * this->dT;
#line 32 "Mono_UO2_CosH_Jaco.mfront"
for (unsigned short s = 0; s != 24; ++s) {
#line 33 "Mono_UO2_CosH_Jaco.mfront"
auto DH0 = real{};
#line 34 "Mono_UO2_CosH_Jaco.mfront"
if (s < 6) {
#line 36 "Mono_UO2_CosH_Jaco.mfront"
this->tau0[s] = 1.179e6;
#line 37 "Mono_UO2_CosH_Jaco.mfront"
DH0 = 4.989 * 1.602e-19;
#line 38 "Mono_UO2_CosH_Jaco.mfront"
} else if ((s >= 6) && (s < 12)) {
#line 39 "Mono_UO2_CosH_Jaco.mfront"
this->tau0[s] = 4.750e6;
#line 40 "Mono_UO2_CosH_Jaco.mfront"
DH0 = 5.246 * 1.602e-19;
#line 41 "Mono_UO2_CosH_Jaco.mfront"
} else {
#line 42 "Mono_UO2_CosH_Jaco.mfront"
this->tau0[s] = 9.215e6;
#line 43 "Mono_UO2_CosH_Jaco.mfront"
DH0 = 12.13 * 1.602e-19;
#line 44 "Mono_UO2_CosH_Jaco.mfront"
}
#line 45 "Mono_UO2_CosH_Jaco.mfront"
this->gp0[s] = rhom * nuD * b * b * exp(-DH0 / (kb * T_));
#line 46 "Mono_UO2_CosH_Jaco.mfront"
}
return true;
}

/*!
 * \brief set the policy for "out of bounds" conditions
 */
void
setOutOfBoundsPolicy(const OutOfBoundsPolicy policy_value){
  this->policy = policy_value;
} // end of setOutOfBoundsPolicy

/*!
* \return the modelling hypothesis
*/
constexpr ModellingHypothesis::Hypothesis
getModellingHypothesis() const{
return hypothesis;
} // end of getModellingHypothesis

//! \brief check physical bounds and standard bounds
void checkBounds() const{
} // end of checkBounds

[[nodiscard]] IntegrationResult computePredictionOperator(const SMFlag,const SMType) override{
tfel::raise("MonoCristal_UO2::computePredictionOperator: "
"unsupported prediction operator flag");
}

real getMinimalTimeStepScalingFactor() const noexcept override{
  return this->minimal_time_step_scaling_factor;
}

std::pair<bool, real>
computeAPrioriTimeStepScalingFactor(const real current_time_step_scaling_factor) const override{
const auto time_scaling_factor = this->computeAPrioriTimeStepScalingFactorII();
return {time_scaling_factor.first,
        std::min(std::min(std::max(time_scaling_factor.second,
                                   this->minimal_time_step_scaling_factor),
                          this->maximal_time_step_scaling_factor),
                  current_time_step_scaling_factor)};
}

/*!
 * \brief Integrate behaviour law over the time step
 */
[[nodiscard]] IntegrationResult integrate(const SMFlag smflag,const SMType smt) override{
using namespace std;
using namespace tfel::math;
this->stiffness_matrix_type = smt;
tfel::math::TinyNewtonRaphsonSolver<ModellingHypothesisToStensorSize<ModellingHypothesis::TRIDIMENSIONAL>::value+24, NumericType, MonoCristal_UO2<ModellingHypothesis::TRIDIMENSIONAL, NumericType, false>>::epsilon = this->epsilon;
tfel::math::TinyNewtonRaphsonSolver<ModellingHypothesisToStensorSize<ModellingHypothesis::TRIDIMENSIONAL>::value+24, NumericType, MonoCristal_UO2<ModellingHypothesis::TRIDIMENSIONAL, NumericType, false>>::iterMax = this->iterMax;
if(!this->solveNonLinearSystem()){
return MechanicalBehaviour<MechanicalBehaviourBase::STANDARDFINITESTRAINBEHAVIOUR,hypothesis, NumericType, false>::FAILURE;
}
if (this->stiffness_matrix_type != NOSTIFFNESSREQUESTED){
this->updateOrCheckJacobian();
}
this->updateIntegrationVariables();
this->updateStateVariables();
this->computeFinalThermodynamicForces();
this->updateAuxiliaryStateVariables();
if(smt!=NOSTIFFNESSREQUESTED){
if(!this->computeConsistentTangentOperator(smflag,smt)){
return MechanicalBehaviour<MechanicalBehaviourBase::STANDARDFINITESTRAINBEHAVIOUR,hypothesis, NumericType, false>::FAILURE;
}
}
return MechanicalBehaviour<MechanicalBehaviourBase::STANDARDFINITESTRAINBEHAVIOUR,hypothesis, NumericType, false>::SUCCESS;
} // end of MonoCristal_UO2::integrate

bool computeResidual(){
return this->computeFdF(false);
}
//! \return the norm of the residual
NumericType computeResidualNorm() {
return tfel::math::norm(this->fzeros) / (StensorSize+24);
}
/*!
 * \brief check the convergence of the method
 * \param[in] error: current error
 */
bool checkConvergence(const NumericType error) {
auto converged = error < this->epsilon;
return converged;
}
/*!
 * \brief update the jacobian matrix if required.
 * \param[in] converged: boolean stating if the method is
 * called after the convergence of the algorithm or before
 * the computation of the next correction.
 *
 * This method can be used to compute the jacobian or part
 * of the jacobian numerically. If the jacobian was computed
 * in `computeResidual`, this method can be used to compare it
 * to a numerical approximation.
 */
void updateOrCheckJacobian(){
}
/*!
 * \brief method meant to set bounds on some components
 * of the current Newton correction or to implement a line
 * search.
 */
void processNewCorrection()
{
}
/*!
 * \brief method meant to process the new estimate.
 *
 * This method may be called to apply bounds on the
 * new estimate and update material properties
 * dependending on the current state.
 */
void processNewEstimate(){
this->updateMaterialPropertiesDependantOnStateVariables();
}
/*!
 * \brief solve linear system
 * \return true on success
 * \param[in] m: matrix
 * \param[in,out] v: right hand side on input, solution on output
 */
bool solveLinearSystem(tfel::math::tmatrix<StensorSize+24, StensorSize+24, NumericType>& mfront_matrix,tfel::math::tvector<StensorSize+24, NumericType>& mfront_vector)const noexcept{
auto mfront_success = true;
mfront_success = tfel::math::TinyNewtonRaphsonSolver<ModellingHypothesisToStensorSize<ModellingHypothesis::TRIDIMENSIONAL>::value+24, NumericType, MonoCristal_UO2<ModellingHypothesis::TRIDIMENSIONAL, NumericType, false>>::solveLinearSystem(mfront_matrix, mfront_vector);
return mfront_success;
}
/*!
* \brief compute fzeros and jacobian
*/
bool computeFdF(const bool perturbatedSystemEvaluation){
using namespace std;
using namespace tfel::math;
using std::vector;
// silent compiler warning
static_cast<void>(perturbatedSystemEvaluation); 
constexpr auto eel_offset = 0;
constexpr auto g_offset = StensorSize;
auto feel = tfel::math::map<StrainStensor, 0>(this->fzeros);
auto fg = tfel::math::map<24, strain, StensorSize>(this->fzeros);
// derivative of residual feel with respect to variable eel
auto&& dfeel_ddeel = tfel::math::map_derivative<0, 0, StrainStensor, StrainStensor>(this->jacobian);
// setting jacobian to identity
std::fill(this->jacobian.begin(),this->jacobian.end(), NumericType(0));
for(ushort mfront_idx = 0; mfront_idx != StensorSize+24; ++mfront_idx){
this->jacobian(mfront_idx, mfront_idx) = NumericType(1);
}
// setting f values to zeros
this->fzeros = this->zeros;
const auto& ss = MonoCristal_UO2SlipSystems<real>::getSlidingSystems();
this->fsscb_data.S = (this->D)*(this->eel+this->deel);
this->fsscb_data.tmp = StrainStensor::Id() + 2*(this->eel+this->deel);
// Mandel stress tensor
const auto M = eval(this->fsscb_data.tmp*(this->fsscb_data.S));
// Mandel stress tensor derivative
const auto dM_ddeel = eval(2*st2tot2<N,real>::tpld(this->fsscb_data.S)+
			    st2tot2<N,real>::tprd(this->fsscb_data.tmp,this->D));
this->fsscb_data.inv_dFp = Tensor::Id();
for(unsigned short i=0;i!=MonoCristal_UO2SlipSystems<real>::Nss;++i){
  this->fsscb_data.inv_dFp -= (this->dg[i])*ss.mu[i];
}
this->fsscb_data.J_inv_dFp = det(this->fsscb_data.inv_dFp);
this->fsscb_data.inv_dFp /= CubicRoots::cbrt(this->fsscb_data.J_inv_dFp);
this->Fe = (this->fsscb_data.Fe_tr)*(this->fsscb_data.inv_dFp);
feel = this->eel+this->deel-computeGreenLagrangeTensor(this->Fe);
const auto fsscb_tprd = t2tot2<N,real>::tprd(this->fsscb_data.Fe_tr);
const auto fsscb_dfeel_dinv_dFp = t2tost2<N,real>::dCdF(this->Fe)*fsscb_tprd;
for(unsigned short i=0;i!=MonoCristal_UO2SlipSystems<real>::Nss;++i){
  dfeel_ddg(i) = (fsscb_dfeel_dinv_dFp)*ss.mu[i]/2;
}
#line 50 "Mono_UO2_CosH_Jaco.mfront"
for (unsigned short s = 0; s != 24; ++s) {
#line 51 "Mono_UO2_CosH_Jaco.mfront"
const auto tau = ss.mu[s] | M ;
#line 52 "Mono_UO2_CosH_Jaco.mfront"
const auto sgn_s = tau >= 0 ? 1 : -1;
#line 53 "Mono_UO2_CosH_Jaco.mfront"
const auto e = exp(tau / (this->tau0)[s]);
#line 54 "Mono_UO2_CosH_Jaco.mfront"
const auto ch = (e + 1 / e) / 2;
#line 55 "Mono_UO2_CosH_Jaco.mfront"
const auto sh = (e - 1 / e) / 2;
#line 56 "Mono_UO2_CosH_Jaco.mfront"
const auto vs = (this->gp0)[s] * (ch - 1);
#line 57 "Mono_UO2_CosH_Jaco.mfront"
const auto dvs_dtau = (this->gp0)[s] * sh / (this->tau0)[s];
#line 58 "Mono_UO2_CosH_Jaco.mfront"
fg[s] -= (this->dt) * sgn_s * vs;
#line 59 "Mono_UO2_CosH_Jaco.mfront"
dfg_ddeel(s) = -(this->dt) * sgn_s * dvs_dtau * (ss.mu[s] | dM_ddeel);
#line 60 "Mono_UO2_CosH_Jaco.mfront"
}
static_cast<void>(dfeel_ddeel); /* suppress potential warnings */
static_cast<void>(eel_offset);
static_cast<void>(g_offset);
return true;
}

std::pair<bool, real>
computeAPosterioriTimeStepScalingFactor(const real current_time_step_scaling_factor) const override{
const auto time_scaling_factor = this->computeAPosterioriTimeStepScalingFactorII();
return {time_scaling_factor.first,
        std::min(std::min(std::max(time_scaling_factor.second,
                                   this->minimal_time_step_scaling_factor),
                          this->maximal_time_step_scaling_factor),
                 current_time_step_scaling_factor)};
}

/*!
* \brief Update the internal energy at end of the time step
* \param[in] Psi_s: internal energy at end of the time step
*/
void computeInternalEnergy(stress& Psi_s) const
{
Psi_s=stress{0};
}

/*!
* \brief Update the dissipated energy at end of the time step
* \param[in] Psi_d: dissipated energy at end of the time step
*/
void computeDissipatedEnergy(stress& Psi_d) const
{
Psi_d=stress{0};
}

bool computeConsistentTangentOperator_DSIG_DF(const SMType smt){
using namespace tfel::math;
// computing DTAU_DDF
if(!this->computeConsistentTangentOperator_DTAU_DDF(smt)){
return false;
}
const t2tost2<N,stress> tangentOperator_DTAU_DDF = this->Dt.template get<t2tost2<N,stress>>();
const auto tangentOperator_DTAU_DF = convert<DTAU_DF,DTAU_DDF>(tangentOperator_DTAU_DDF,this->F0,this->F1,this->sig);
this->Dt = convert<DSIG_DF,DTAU_DF>(tangentOperator_DTAU_DF,this->F0,this->F1,this->sig);
return true;
}

bool computeConsistentTangentOperator_DSIG_DDF(const SMType smt){
using namespace tfel::math;
// computing DTAU_DDF
if(!this->computeConsistentTangentOperator_DTAU_DDF(smt)){
return false;
}
const t2tost2<N,stress> tangentOperator_DTAU_DDF = this->Dt.template get<t2tost2<N,stress>>();
const auto tangentOperator_DTAU_DF = convert<DTAU_DF,DTAU_DDF>(tangentOperator_DTAU_DDF,this->F0,this->F1,this->sig);
const auto tangentOperator_DSIG_DF = convert<DSIG_DF,DTAU_DF>(tangentOperator_DTAU_DF,this->F0,this->F1,this->sig);
this->Dt = convert<DSIG_DDF,DSIG_DF>(tangentOperator_DSIG_DF,this->F0,this->F1,this->sig);
return true;
}

bool computeConsistentTangentOperator_C_TRUESDELL(const SMType smt){
using namespace tfel::math;
// computing DTAU_DDF
if(!this->computeConsistentTangentOperator_DTAU_DDF(smt)){
return false;
}
const t2tost2<N,stress> tangentOperator_DTAU_DDF = this->Dt.template get<t2tost2<N,stress>>();
const auto tangentOperator_DTAU_DF = convert<DTAU_DF,DTAU_DDF>(tangentOperator_DTAU_DDF,this->F0,this->F1,this->sig);
const auto tangentOperator_SPATIAL_MODULI = convert<SPATIAL_MODULI,DTAU_DF>(tangentOperator_DTAU_DF,this->F0,this->F1,this->sig);
this->Dt = convert<C_TRUESDELL,SPATIAL_MODULI>(tangentOperator_SPATIAL_MODULI,this->F0,this->F1,this->sig);
return true;
}

bool computeConsistentTangentOperator_SPATIAL_MODULI(const SMType smt){
using namespace tfel::math;
// computing DTAU_DDF
if(!this->computeConsistentTangentOperator_DTAU_DDF(smt)){
return false;
}
const t2tost2<N,stress> tangentOperator_DTAU_DDF = this->Dt.template get<t2tost2<N,stress>>();
const auto tangentOperator_DTAU_DF = convert<DTAU_DF,DTAU_DDF>(tangentOperator_DTAU_DDF,this->F0,this->F1,this->sig);
this->Dt = convert<SPATIAL_MODULI,DTAU_DF>(tangentOperator_DTAU_DF,this->F0,this->F1,this->sig);
return true;
}

bool computeConsistentTangentOperator_C_TAU_JAUMANN(const SMType smt){
using namespace tfel::math;
// computing DTAU_DDF
if(!this->computeConsistentTangentOperator_DTAU_DDF(smt)){
return false;
}
const t2tost2<N,stress> tangentOperator_DTAU_DDF = this->Dt.template get<t2tost2<N,stress>>();
const auto tangentOperator_DTAU_DF = convert<DTAU_DF,DTAU_DDF>(tangentOperator_DTAU_DDF,this->F0,this->F1,this->sig);
this->Dt = convert<C_TAU_JAUMANN,DTAU_DF>(tangentOperator_DTAU_DF,this->F0,this->F1,this->sig);
return true;
}

bool computeConsistentTangentOperator_ABAQUS(const SMType smt){
using namespace tfel::math;
// computing DTAU_DDF
if(!this->computeConsistentTangentOperator_DTAU_DDF(smt)){
return false;
}
const t2tost2<N,stress> tangentOperator_DTAU_DDF = this->Dt.template get<t2tost2<N,stress>>();
const auto tangentOperator_DTAU_DF = convert<DTAU_DF,DTAU_DDF>(tangentOperator_DTAU_DDF,this->F0,this->F1,this->sig);
this->Dt = convert<ABAQUS,DTAU_DF>(tangentOperator_DTAU_DF,this->F0,this->F1,this->sig);
return true;
}

bool computeConsistentTangentOperator_DSIG_DDE(const SMType){
tfel::raise("MonoCristal_UO2::computeConsistentTangentOperator_DSIG_DDE: "
"computing the tangent operator 'DSIG_DDE' is not supported");
}

bool computeConsistentTangentOperator_DTAU_DF(const SMType smt){
using namespace tfel::math;
// computing DTAU_DDF
if(!this->computeConsistentTangentOperator_DTAU_DDF(smt)){
return false;
}
const t2tost2<N,stress> tangentOperator_DTAU_DDF = this->Dt.template get<t2tost2<N,stress>>();
this->Dt = convert<DTAU_DF,DTAU_DDF>(tangentOperator_DTAU_DDF,this->F0,this->F1,this->sig);
return true;
}

bool computeConsistentTangentOperator_DTAU_DDF(const SMType smt){
using namespace std;
using namespace tfel::math;
using std::vector;
auto mfront_success = true;
TinyPermutation<StensorSize+24> jacobian_permutation;
if(!TinyMatrixSolve<StensorSize+24, NumericType, false>::decomp(this->jacobian,jacobian_permutation)){
return false;
}
struct TFEL_VISIBILITY_LOCAL GetPartialJacobianInvert{
GetPartialJacobianInvert(MonoCristal_UO2& mfront_behaviour_argument,
const tfel::math::TinyPermutation<StensorSize+24>& mfront_permutation_argument,
bool& mfront_success_argument)
: mfront_get_partial_jacobian_invert_behaviour(mfront_behaviour_argument),
mfront_get_partial_jacobian_invert_permutation(mfront_permutation_argument),
mfront_success_reference(mfront_success_argument){}
void operator()(tfel::math::derivative_type<StrainStensor, StrainStensor>& partial_jacobian_eel){
if(!this->mfront_get_partial_jacobian_invert_behaviour.computePartialJacobianInvert(this->mfront_get_partial_jacobian_invert_permutation, partial_jacobian_eel)){
this->mfront_success_reference = false;
}
}
void operator()(tfel::math::derivative_type<StrainStensor, StrainStensor>& partial_jacobian_eel,
tfel::math::tvector<24, tfel::math::derivative_type<strain, StrainStensor>>& partial_jacobian_g){
if(!this->mfront_get_partial_jacobian_invert_behaviour.computePartialJacobianInvert(this->mfront_get_partial_jacobian_invert_permutation, partial_jacobian_eel,
partial_jacobian_g)){
this->mfront_success_reference = false;
}
}
private:
MonoCristal_UO2& mfront_get_partial_jacobian_invert_behaviour;
const tfel::math::TinyPermutation<StensorSize+24>& mfront_get_partial_jacobian_invert_permutation;
bool& mfront_success_reference;
}; // end of struct GetPartialJacobianInvert
GetPartialJacobianInvert getPartialJacobianInvert(*this, jacobian_permutation, mfront_success);
static_cast<void>(smt);
const auto& ss = MonoCristal_UO2SlipSystems<real>::getSlidingSystems();
const auto fsscb_dC_dFe = t2tost2<N,real>::dCdF(this->Fe);
const auto fsscb_dS_dFe = eval((this->D)*fsscb_dC_dFe/2);
const auto fsscb_dtau_dFe = computePushForwardDerivative(fsscb_dS_dFe,this->fsscb_data.S,this->Fe);
const auto fsscb_dFe_dDF_tot = t2tot2<N,real>::tpld(this->fsscb_data.inv_dFp,                     t2tot2<N,real>::tpld(this->fsscb_data.Fe0));
const auto fsscb_dfeel_dDF = eval(-(fsscb_dC_dFe)*(fsscb_dFe_dDF_tot)/2);
st2tost2<N,real> fsscb_Je;
tvector<MonoCristal_UO2SlipSystems<real>::Nss,Stensor> fsscb_Jg;
getPartialJacobianInvert(fsscb_Je,fsscb_Jg);
t2tot2<N,real> fsscb_dinv_Fp_dDF = (ss.mu[0])^(fsscb_Jg[0]|fsscb_dfeel_dDF);
for(unsigned short i=1;i!=MonoCristal_UO2SlipSystems<real>::Nss;++i){
  fsscb_dinv_Fp_dDF += (ss.mu[i])^(fsscb_Jg[i]|fsscb_dfeel_dDF);
}
const auto fsscb_dFe_dDF=
  fsscb_dFe_dDF_tot+t2tot2<N,real>::tprd(this->fsscb_data.Fe_tr,fsscb_dinv_Fp_dDF);
Dt = fsscb_dtau_dFe*fsscb_dFe_dDF;

return mfront_success;
}

bool computeConsistentTangentOperator_DS_DF(const SMType smt){
using namespace tfel::math;
// computing DTAU_DDF
if(!this->computeConsistentTangentOperator_DTAU_DDF(smt)){
return false;
}
const t2tost2<N,stress> tangentOperator_DTAU_DDF = this->Dt.template get<t2tost2<N,stress>>();
const auto tangentOperator_DTAU_DF = convert<DTAU_DF,DTAU_DDF>(tangentOperator_DTAU_DDF,this->F0,this->F1,this->sig);
const auto tangentOperator_SPATIAL_MODULI = convert<SPATIAL_MODULI,DTAU_DF>(tangentOperator_DTAU_DF,this->F0,this->F1,this->sig);
const auto tangentOperator_DS_DEGL = convert<DS_DEGL,SPATIAL_MODULI>(tangentOperator_SPATIAL_MODULI,this->F0,this->F1,this->sig);
this->Dt = convert<DS_DF,DS_DEGL>(tangentOperator_DS_DEGL,this->F0,this->F1,this->sig);
return true;
}

bool computeConsistentTangentOperator_DS_DDF(const SMType){
tfel::raise("MonoCristal_UO2::computeConsistentTangentOperator_DS_DDF: "
"computing the tangent operator 'DS_DDF' is not supported");
}

bool computeConsistentTangentOperator_DS_DC(const SMType smt){
using namespace tfel::math;
// computing DTAU_DDF
if(!this->computeConsistentTangentOperator_DTAU_DDF(smt)){
return false;
}
const t2tost2<N,stress> tangentOperator_DTAU_DDF = this->Dt.template get<t2tost2<N,stress>>();
const auto tangentOperator_DTAU_DF = convert<DTAU_DF,DTAU_DDF>(tangentOperator_DTAU_DDF,this->F0,this->F1,this->sig);
const auto tangentOperator_SPATIAL_MODULI = convert<SPATIAL_MODULI,DTAU_DF>(tangentOperator_DTAU_DF,this->F0,this->F1,this->sig);
const auto tangentOperator_DS_DEGL = convert<DS_DEGL,SPATIAL_MODULI>(tangentOperator_SPATIAL_MODULI,this->F0,this->F1,this->sig);
this->Dt = convert<DS_DC,DS_DEGL>(tangentOperator_DS_DEGL,this->F0,this->F1,this->sig);
return true;
}

bool computeConsistentTangentOperator_DS_DEGL(const SMType smt){
using namespace tfel::math;
// computing DTAU_DDF
if(!this->computeConsistentTangentOperator_DTAU_DDF(smt)){
return false;
}
const t2tost2<N,stress> tangentOperator_DTAU_DDF = this->Dt.template get<t2tost2<N,stress>>();
const auto tangentOperator_DTAU_DF = convert<DTAU_DF,DTAU_DDF>(tangentOperator_DTAU_DDF,this->F0,this->F1,this->sig);
const auto tangentOperator_SPATIAL_MODULI = convert<SPATIAL_MODULI,DTAU_DF>(tangentOperator_DTAU_DF,this->F0,this->F1,this->sig);
this->Dt = convert<DS_DEGL,SPATIAL_MODULI>(tangentOperator_SPATIAL_MODULI,this->F0,this->F1,this->sig);
return true;
}

bool computeConsistentTangentOperator_DT_DELOG(const SMType){
tfel::raise("MonoCristal_UO2::computeConsistentTangentOperator_DT_DELOG: "
"computing the tangent operator 'DT_DELOG' is not supported");
}

bool computeConsistentTangentOperator_DPK1_DF(const SMType smt){
using namespace tfel::math;
// computing DTAU_DDF
if(!this->computeConsistentTangentOperator_DTAU_DDF(smt)){
return false;
}
const t2tost2<N,stress> tangentOperator_DTAU_DDF = this->Dt.template get<t2tost2<N,stress>>();
const auto tangentOperator_DTAU_DF = convert<DTAU_DF,DTAU_DDF>(tangentOperator_DTAU_DDF,this->F0,this->F1,this->sig);
const auto tangentOperator_DSIG_DF = convert<DSIG_DF,DTAU_DF>(tangentOperator_DTAU_DF,this->F0,this->F1,this->sig);
this->Dt = convert<DPK1_DF,DSIG_DF>(tangentOperator_DSIG_DF,this->F0,this->F1,this->sig);
return true;
}

bool computeConsistentTangentOperator(const SMFlag smflag,const SMType smt){
switch(smflag){
case DSIG_DF:
return this->computeConsistentTangentOperator_DSIG_DF(smt);
case DSIG_DDF:
return this->computeConsistentTangentOperator_DSIG_DDF(smt);
case C_TRUESDELL:
return this->computeConsistentTangentOperator_C_TRUESDELL(smt);
case SPATIAL_MODULI:
return this->computeConsistentTangentOperator_SPATIAL_MODULI(smt);
case C_TAU_JAUMANN:
return this->computeConsistentTangentOperator_C_TAU_JAUMANN(smt);
case ABAQUS:
return this->computeConsistentTangentOperator_ABAQUS(smt);
case DSIG_DDE:
return this->computeConsistentTangentOperator_DSIG_DDE(smt);
case DTAU_DF:
return this->computeConsistentTangentOperator_DTAU_DF(smt);
case DTAU_DDF:
return this->computeConsistentTangentOperator_DTAU_DDF(smt);
case DS_DF:
return this->computeConsistentTangentOperator_DS_DF(smt);
case DS_DDF:
return this->computeConsistentTangentOperator_DS_DDF(smt);
case DS_DC:
return this->computeConsistentTangentOperator_DS_DC(smt);
case DS_DEGL:
return this->computeConsistentTangentOperator_DS_DEGL(smt);
case DT_DELOG:
return this->computeConsistentTangentOperator_DT_DELOG(smt);
case DPK1_DF:
return this->computeConsistentTangentOperator_DPK1_DF(smt);
}
tfel::raise("MonoCristal_UO2::computeConsistentTangentOperator: "
"unsupported tangent operator flag");
}

/*!
* \brief compute the sound velocity
* \param[in] rho_m0: mass density in the reference configuration
*/
speed computeSpeedOfSound(const massdensity&) const {
return speed(0);

}

const TangentOperator& getTangentOperator() const{
return this->Dt;
}

void updateExternalStateVariables(){
this->F0  = this->F1;
this->T += this->dT;
}

//!
~MonoCristal_UO2()
 override = default;

private:

std::pair<bool, real> computeAPrioriTimeStepScalingFactorII() const{
return {true, this->maximal_time_step_scaling_factor};
}

std::pair<bool, real> computeAPosterioriTimeStepScalingFactorII() const{
return {true,this->maximal_time_step_scaling_factor};
}

//! policy for treating out of bounds conditions
OutOfBoundsPolicy policy = tfel::material::None;

}; // end of MonoCristal_UO2 class

template<typename NumericType>
std::ostream&
operator <<(std::ostream& os,const MonoCristal_UO2<ModellingHypothesis::TRIDIMENSIONAL, NumericType, false>& b)
{
os << "F₀ : " << b.F0 << '\n';
os << "F₁ : " << b.F1 << '\n';
os << "σ : " << b.sig << '\n';
os << "Δt : " << b.dt << '\n';
os << "g : " << b.g << '\n';
os << "Δg : " << b.dg << '\n';
os << "Fe : " << b.Fe << '\n';
os << "T : " << b.T << '\n';
os << "ΔT : " << b.dT << '\n';
os << "ε : " << b.epsilon << '\n';
os << "θ : " << b.theta << '\n';
os << "iterMax : " << b.iterMax << '\n';
os << "minimal_time_step_scaling_factor : " << b.minimal_time_step_scaling_factor << '\n';
os << "maximal_time_step_scaling_factor : " << b.maximal_time_step_scaling_factor << '\n';
os << "numerical_jacobian_epsilon : " << b.numerical_jacobian_epsilon << '\n';
return os;
}

/*!
* Partial specialisation for MonoCristal_UO2.
*/
template<ModellingHypothesis::Hypothesis hypothesis, typename NumericType>
class MechanicalBehaviourTraits<MonoCristal_UO2<hypothesis, NumericType, false> >
{
using size_type = unsigned short;
public:
static constexpr bool is_defined = false;
static constexpr bool use_quantities = false;
//! orthotropic axes convention
static constexpr OrthotropicAxesConvention oac = OrthotropicAxesConvention::DEFAULT;
static constexpr bool hasStressFreeExpansion = false;
static constexpr bool handlesThermalExpansion = false;
static constexpr unsigned short dimension = 0u;
static constexpr size_type material_properties_nb = 0;
static constexpr size_type internal_variables_nb  = 0;
static constexpr size_type external_variables_nb  = 0;
static constexpr size_type external_variables_nb2 = 0;
static constexpr bool hasConsistentTangentOperator = false;
static constexpr bool isConsistentTangentOperatorSymmetric = false;
static constexpr bool hasPredictionOperator = false;
static constexpr bool hasAPrioriTimeStepScalingFactor = false;
static constexpr bool hasComputeInternalEnergy = false;
static constexpr bool hasComputeDissipatedEnergy = false;
/*!
* \return the name of the class.
*/
static const char* getName(){
return "MonoCristal_UO2";
}

};

/*!
* Partial specialisation for MonoCristal_UO2.
*/
template<typename NumericType>
class MechanicalBehaviourTraits<MonoCristal_UO2<ModellingHypothesis::TRIDIMENSIONAL, NumericType, false> >
{
using size_type = unsigned short;
static constexpr unsigned short N = ModellingHypothesisToSpaceDimension<ModellingHypothesis::TRIDIMENSIONAL>::value;
static constexpr unsigned short TVectorSize = N;
typedef tfel::math::StensorDimeToSize<N> StensorDimeToSize;
static constexpr unsigned short StensorSize = StensorDimeToSize::value;
typedef tfel::math::TensorDimeToSize<N> TensorDimeToSize;
static constexpr unsigned short TensorSize = TensorDimeToSize::value;
public:
static constexpr bool is_defined = true;
static constexpr bool use_quantities = false;
//! orthotropic axes convention
static constexpr OrthotropicAxesConvention oac = OrthotropicAxesConvention::DEFAULT;
static constexpr bool hasStressFreeExpansion = false;
static constexpr bool handlesThermalExpansion = false;
static constexpr unsigned short dimension = N;
static constexpr size_type material_properties_nb = 0;
static constexpr size_type internal_variables_nb  = 24+TensorSize;
static constexpr size_type external_variables_nb  = 1;
static constexpr size_type external_variables_nb2 = 0;
static constexpr bool hasConsistentTangentOperator = true;
static constexpr bool isConsistentTangentOperatorSymmetric = false;
static constexpr bool hasPredictionOperator = false;
static constexpr bool hasAPrioriTimeStepScalingFactor = false;
static constexpr bool hasComputeInternalEnergy = false;
static constexpr bool hasComputeDissipatedEnergy = false;
/*!
* \return the name of the class.
*/
static const char* getName(){
return "MonoCristal_UO2";
}

};

} // end of namespace tfel::material

#endif /* LIB_TFELMATERIAL_MONOCRISTAL_UO2_HXX */
